---
layout: post
title: Writing a Windows Service on a Timer with .Net
date: '2013-01-05T15:51:00.002-05:00'
author: Carlo
tags:
- ".NET"
- Threading
- System.Threading.Timer
- Windows
- C#
- Service
- Timer
modified_time: '2013-01-05T15:51:27.022-05:00'
thumbnail: http://4.bp.blogspot.com/-waxLJq_PVbA/UOhwldUz4WI/AAAAAAABiyw/VVUsCKAGF6M/s72-c/NewService.png
blogger_id: tag:blogger.com,1999:blog-1115978604548657664.post-4670864206674362784
blogger_orig_url: https://thewahlstedts.blogspot.com/2013/01/writing-windows-service-on-timer-with.html
---

<h4>Creating the Service</h4>I recently was tasked with writing a Windows Service. I had never done this before but it seemed to me that it couldn't be that difficult. So I did what any good software engineer would do. I fired up Visual Studio 2012, opened my sample solution I use to test code in, and added a new project selecting the Windows Service template. <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-waxLJq_PVbA/UOhwldUz4WI/AAAAAAABiyw/VVUsCKAGF6M/s1600/NewService.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-waxLJq_PVbA/UOhwldUz4WI/AAAAAAABiyw/VVUsCKAGF6M/s1600/NewService.png" /></a></div><br /><br />After this new project is created you start out with several files and I quickly realized I should probably read a tutorial on what to do. A quick google search lead me to an <a href="http://msdn.microsoft.com/en-us/library/aa984464(v=vs.71).aspx" target="_blank">MSDN article</a>. After reading through the article and following some links to others I followed the tutorial to create the service.<br /><h4>Debugging the Service</h4>After getting the service created and setting it up to call the classes needed to do the work for the service I had to find a way to debug the service. There are actually two ways to debug the service, one is to create a separate test harness project (I used WinForms) that will just call the classes that are doing the work. You can setup different buttons that will call the different parts and use that for your testing. In order to debug the service in the other way you will have to install it locally on your machine and attach the VS debugger to it. One way to do this more "automatically" is to add the following line where you want to start debugging:<br /><br /><pre class="brush:java">Debugger.Break()</pre><br />It will then show a box asking you what you want to use to debug the service with.<br /><h4>Making the Service Work</h4>When I got to the point of checking to see what I had actually written to was going to work as a service I had a little surprise. When I started my service it would only run the OnStart method once. I had not really thought this through and assume that there would be some form of a quick and easy build-in timer to use. Since this was not the case, I had to do a little searching. The conclusion I came to was there was not one source that gave me a single, good solution.<br /><br />The best solution I was able to put together was to use a System.Threading.Timer. This is a timer on a new thread. I allows you to start the service and check something every x minutes with a timer. When the timer runs you will want to check to make sure that you are not already processing so that you don't process twice at the same time. The OnStop method is written to allow the service 60 seconds to stop processing and doing what it is doing before you just kill the service.<br /><h4>Final Solution</h4>Here's the solution in one chunk of code:<br /><pre class="brush:java">public partial class Service : ServiceBase<br />{<br />    private Main _service = new Main();<br />    private System.Threading.Timer _serviceTimer;<br />    private bool _isRunning = false;<br /><br />    protected override void OnStart(string[] args)<br />    {<br />        //Handles the unhandled things so issues will be logged<br />        AppDomain currentDomain = AppDomain.CurrentDomain;<br />        currentDomain.UnhandledException += HandleUnhandledExceptions;<br />        currentDomain.AssemblyResolve += HandleAssemblyResolve;<br />        currentDomain.DomainUnload += HandleDomainUnload;<br />        currentDomain.ProcessExit += HandleProcessExit;<br />        currentDomain.TypeResolve += HandleTypeResolve;<br />        currentDomain.ResourceResolve += HandleResourceResolve;<br /><br />        try<br />        {<br />            //create timer and attach our method delegate to it<br />            System.Threading.TimerCallback timerDelegate = new System.Threading.TimerCallback(DoWork);<br />            _serviceTimer = new System.Threading.Timer(timerDelegate, null, 1000, 300000);<br />        }<br />        catch (Exception ex)<br />        {<br />            Debug.WriteLine(ex.ToString());<br />        }<br />    }<br /><br />    /// The "timer" thread that gets called<br />    private void DoWork(object state)<br />    {<br />        //only do anything if it is not already running<br />        if (!_isRunning)<br />        {<br />            try<br />            {<br />                //Debugger.Break();<br /><br />                _isRunning = true;<br />                _service.Start();<br />            }<br />            catch (Exception ex)<br />            {<br />                Debug.WriteLine(ex.ToString());<br />            }<br />            finally<br />            {<br />                _isRunning = false;<br />            }<br />        }<br />    }<br /><br />    protected override void OnStop()<br />    {<br />        //Don't stop while the timer is running or if we have waited 60 seconds<br />        int secondsCounter = 0;<br />        while (_isRunning &amp;&amp; secondsCounter &lt;= 60)<br />        {<br />            System.Threading.Thread.Sleep(1000);<br />            secondsCounter++;<br />        }<br />    }<br />}</pre>